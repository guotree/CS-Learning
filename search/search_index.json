{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computer Science Self Learning Guideline","text":"<p>This computer science self-learning guide draws inspiration from \"Teach Yourself Computer Science\" and \"csdiy.wiki\" presenting the content in a more streamlined and efficient manner.</p> <p>Meanwhile, the following guidelines can also serve as your reference.</p> <ul> <li>r/learningprogramming</li> <li>might.net</li> <li>A Self-Learning, Modern Computer Science Curriculum</li> <li>Open Source Society University</li> <li>UCB course guides</li> </ul>      There are 2 types of software engineer: those who understand computer science well enough to do challenging,      innovative work, and those who just get by because they\u2019re familiar with a few high level tools.      Both call themselves software engineers, and both tend to earn similar salaries in their early careers.      But Type 1 engineers progress toward more fulfilling and well-remunerated work over time,      whether that\u2019s valuable commercial work or breakthrough open-source projects,      technical leadership or high-quality individual contributions.  <p>Your self-learning journey should encompass 11 essential areas:</p> <ol> <li>Programming</li> <li>Computer Architecture</li> <li>Algorithms and Data Structures</li> <li>Math for CS</li> <li>Operating Systems</li> <li>Computer Networking</li> <li>Databases</li> <li>Languages and Compilers</li> <li>Distributed Systems</li> <li>Artificial Intelligence</li> <li>Others</li> </ol> <p>Before embarking on your self-learning adventure, we recommend starting with an introductory course:  Crash Course Computer Science by  Carrie Anne. Here is my Notes</p> <p>This series will provide an excellent foundation for your studies.</p> <p>The recommended content will be marked with a star and displayed in bold at the beginning of the text, while the content I have completed will be marked with a checkmark and set to green at the end of the text.</p>"},{"location":"links/","title":"Useful Links","text":"<p>Here are some useful websites:</p>"},{"location":"links/#courses","title":"Courses","text":"<ul> <li>Youtube<ul> <li>Stanford Online</li> <li>caltech</li> <li>MIT OpenCourseWare</li> <li>Hsuan-Tien Lin</li> <li>The Coding Sloth</li> <li>3Blue1Brown</li> <li>Ben Eater</li> <li>Chuck Severance</li> <li>DeepLearningAI</li> <li>w3schools.com</li> <li>freeCodeCamp.org</li> <li>Khan Academy</li> <li>CrashCourse</li> </ul> </li> <li>Bilibili<ul> <li>CrashCourse\u5b57\u5e55\u7ec4</li> <li>CS\u81ea\u5b66\u793e\u533a</li> <li>\u6e05\u534e\u9093\u535a\u58eb</li> <li>GPT\u4e2d\u82f1\u5b57\u5e55\u8bfe\u7a0b\u8d44\u6e90</li> <li>\u7231\u53ef\u53ef-\u7231\u751f\u6d3b</li> <li>shuhuai008</li> </ul> </li> <li>MIT OpenCourseWare</li> <li>InfoCoBuild</li> <li>Coursera</li> <li>edX</li> </ul>"},{"location":"links/#books","title":"Books","text":"<ul> <li>Anna\u2019s Archive</li> <li>Zlibrary</li> <li>Scihub</li> </ul>"},{"location":"links/#exercise","title":"Exercise","text":"<ul> <li>LeetCode</li> <li>SQLZoo</li> <li>Kaggle</li> <li>DataCamp</li> <li>Exercism</li> </ul>"},{"location":"links/#tools","title":"Tools","text":"<ul> <li>Internet Archive</li> <li>Kimi</li> <li>Claude</li> <li>Monica</li> <li>Zotero</li> <li>Obsidian</li> <li>Overleaf</li> <li>Draw.io</li> <li>Excalidraw</li> </ul>"},{"location":"templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/ai/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/ai/Harvard-Data-Science/","title":"HarvardX Data Science","text":"<p>This is a note repository for learning HarvardX Data Science Professional Certificate | edX which is teaching in R. It consists of 9 separate courses:</p> Course Name Course Link Note Link Progress R Basics link Note01 100% Visualization link Note02 100% Probability link Note03 100% Inference and Modeling link Note04 100% Productivity Tools link Note05 100% Wrangling link Note06 45% Linear Regression link Note07 - Machine Learning link Note08 - Capstone link Note09 - <p>However the core material is two HTML book:</p> <ul> <li>Introduction to Data Science: Data Wrangling and Visualization with R</li> <li>Introduction to Data Science: Statistics and Prediction Algorithms Through Case Studies</li> </ul> <p>I think this book is sufficient to guide you through mastering the series of courses! Exercises and quiz are also important, so do them yourself.</p>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/","title":"R Basics","text":"<p>This course includes 4 sections: </p> <ul> <li>Section 1: R Basics</li> <li>Section 2: Data Wrangling</li> <li>Section 3: Programming Basics</li> <li>Section 4: Importing Data</li> </ul> <p>These four sections correspond to the first chapter of the first book.</p> <p>I will take notes in the order of the book rather than the order of the video.</p>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#1-getting-started","title":"1. Getting Started","text":"<p>As an undergraduate student taking notes from the online book \"Introduction to Data Science - Getting Started with R,\" here are the key points to consider:</p>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#why-r","title":"Why R?","text":"<ul> <li>Origin: Developed by statisticians for interactive data analysis, not for general software development like C or Java.</li> <li>Interactivity: Essential for quick data exploration in data science.</li> <li>Scripting: Ability to save work as scripts for record-keeping and reproducibility.</li> <li>Differences: Not conventional like other programming languages; offers unique power in data analysis and visualization.</li> <li>Other Attractive Features of R<ol> <li>Free and Open Source: Accessible to all users.</li> <li>Cross-Platform: Runs on Windows, macOS, UNIX/Linux.</li> <li>Seamless Sharing: Scripts and data objects can be shared across different platforms.</li> <li>Active Community: Large, growing, and supportive with numerous learning resources.</li> <li>Extensibility: Easy to contribute and share new data science methodologies across various disciplines.</li> </ol> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#the-r-console","title":"The R Console","text":"<ul> <li>Function: Used for interactive data analysis, executing commands as typed.</li> <li>Access: Can be accessed by starting R on a computer.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#rstudio","title":"RStudio","text":"<ul> <li>Role: Serves as a launching pad for data science projects with an editor, console, and other tools.</li> <li>Panes: Four main panes for different functionalities (code editor, console, environment/history/connections/tutorial, files/plots/packages/help/viewer/presentation).</li> <li>Key Bindings: Keyboard shortcuts for efficient task performance, recommended to memorize for common operations.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#installing-r-packages","title":"Installing R Packages","text":"<ul> <li>Base R: Limited functionality; extended by add-ons from developers.</li> <li>CRAN and GitHub: Sources for packages, with hundreds available.</li> <li>Installation: Easy installation from within R or RStudio. <code>install.packages()</code></li> <li>Loading Packages: Use <code>library()</code> to load installed packages into R sessions.</li> <li>Dependencies: Some packages install additional required packages automatically.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#2-r-basic","title":"2. R basic","text":"<p>Motivating Example: US Gun Murders you can load the data through <code>data(murders)</code>.</p>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#the-very-basics-of-r","title":"The Very Basics of R","text":"<ul> <li>Objects: Storing values for later use with <code>&lt;-</code> for assignment<ul> <li>Example: Solving quadratic equations using variables</li> </ul> </li> <li>Workspace: The environment where objects are stored and can be accessed<ul> <li>Viewing workspace variables in RStudio's Environment tab</li> <li>Methods to save and load workspaces using <code>save</code>, <code>save.image</code>, and <code>load</code></li> </ul> </li> <li>Prebuilt Functions and Objects<ul> <li>Prebuilt Functions<ul> <li>Using predefined functions like <code>sqrt</code>, <code>log</code> for calculations</li> <li>You can get help by using the\u00a0<code>help</code>\u00a0function like this: <code>help(\"log\")</code> or <code>?log</code></li> </ul> </li> <li>Prebuilt Objects<ul> <li>You can see all available prebuilt datasets using <code>data()</code></li> <li>mathematical quantities like <code>pi</code> and <code>Inf</code></li> </ul> </li> </ul> </li> <li>Variable Names in R: \u00a0start with a letter, can\u2019t contain spaces, and avoid conflicts with existing functions or reserved words in the language</li> <li>Comment: comments start with the symbol\u00a0<code>#</code></li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#data-types-in-r","title":"Data Types in R","text":"<p>Using <code>class()</code> to identify the type of an object; The function\u00a0<code>str</code>\u00a0is useful for finding out more about the structure of an object.</p> <ul> <li>Data Frames<ul> <li>Storing datasets in data frames as tables with observations and variables</li> <li>Accessing data frames and their structure using <code>str()</code> and <code>head()</code></li> <li>Using <code>$</code> to access variables within a data frame</li> <li>Naming and accessing vector entries</li> </ul> </li> <li>Vectors<ul> <li>Creating and manipulating vectors with <code>c()</code> and accessing elements</li> <li>types: \"numeric\", \"character\", \"logical\", \"factor\", \"integer\"</li> <li>Numbers default to the numeric class, even if they are whole numbers. To convert to integers, use <code>as.integer()</code> or suffix with <code>L</code> (e.g., <code>1L</code>).</li> </ul> </li> <li>Factor: Storing categorical data and ordering levels with <code>factor</code> and <code>reorder</code> (different from character)</li> <li> <p>Lists</p> <ul> <li>Data frames are a special case of\u00a0lists. Lists are useful because you can store any combination of different types. You can create a list using the\u00a0<code>list</code>\u00a0function like this:</li> </ul> S<pre><code>record &lt;- list(name = \"John Doe\",\n              student_id = 1234,\n              grades = c(95, 82, 91, 97, 93),\n              final_grade = \"A\")\n\nrecord$student_id\n#&gt; [1] 1234\nrecord[[\"student_id\"]]\n#&gt; [1] 1234\n</code></pre> <ul> <li>you can extract the components of a list with the accessor\u00a0<code>$</code> or double square brackets (<code>[[</code>)</li> <li>Matrices</li> <li>Defining matrices for matrix algebra operations and converting to data frames</li> <li>entries in matrices have to be all the same type</li> <li>We can define a matrix using the\u00a0<code>matrix</code>\u00a0function like:</li> </ul> S<pre><code>mat &lt;- matrix(1:12, 4, 3)\nmat\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    5    9\n#&gt; [2,]    2    6   10\n#&gt; [3,]    3    7   11\n#&gt; [4,]    4    8   12\n</code></pre> <ul> <li>We can access elements in the matrix in a similar manner to numpy</li> <li>We can convert matrices into data frames using the function\u00a0<code>as.data.frame</code></li> </ul> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#more-of-vectors","title":"More of Vectors","text":"<ul> <li>names:</li> </ul> S<pre><code>codes &lt;- c(italy = 380, canada = 124, egypt = 818)\ncodes \n#&gt; italy canada egypt \n#&gt; 380 124 818\nnames(codes)\n#&gt; [1] \"italy\"  \"canada\" \"egypt\"\n#another way to assign name\ncodes &lt;- c(380, 124, 818)\ncountry &lt;- c(\"italy\",\"canada\",\"egypt\")\nnames(codes) &lt;- country\ncodes\n#&gt;  italy canada  egypt \n#&gt;    380    124    818\n</code></pre> <ul> <li>Use <code>seq</code> for creating vectors generates sequance</li> <li>Subsetting: We use square brackets to access specific elements of a vector.</li> <li>Coercion: When an entry does not match the expected, some of the prebuilt R functions try to guess what was meant before throwing an error. <code>as.numeric</code>, <code>as.character</code>; a special value called an\u00a0<code>NA</code>\u00a0for \u201cnot available\u201d</li> </ul> S<pre><code>x &lt;- c(1, \"canada\", 3)\nx\n#&gt; [1] \"1\"      \"canada\" \"3\"\nclass(x)\n#&gt; [1] \"character\"\n</code></pre> <ul> <li>Sorting and Ordering<ul> <li><code>sort</code> return the sorted vector in increasing order.</li> <li><code>order</code> \u00a0takes a vector as input and returns the vector of indexes that sorts the input vector</li> <li><code>rank</code> For any given vector it returns a vector with the rank of the first entry, second entry, etc., of the input vector.</li> <li><code>max</code> and <code>min</code> return the value.</li> <li><code>which.max</code> and <code>which.min</code> return the index.</li> </ul> </li> <li>Vector arithmetics:<ul> <li>arithmetic operations on vectors occur\u00a0element-wise</li> <li>If we have two vectors of the same length, and we sum them in R, they will be added entry by entry as follows:</li> </ul> </li> </ul> \\[ \\begin{pmatrix}a \\\\b \\\\c \\\\d\\end{pmatrix}+\\begin{pmatrix}e \\\\f \\\\g \\\\h\\end{pmatrix}=\\begin{pmatrix}a+e \\\\b+f \\\\c+g \\\\d+h\\end{pmatrix} \\] <ul> <li>if the vectors don\u2019t match in length, \u00a0R has recycled the numbers in the\u00a0short vector</li> <li>Indexing:<ul> <li>we can use logicals to index vectors<ul> <li>logical operator: <code>==</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>&amp;&amp;</code>, <code>||</code></li> <li><code>&amp;</code>and <code>|</code> are Element-wise Logical operator</li> <li><code>&amp;&amp;</code> and <code>||</code> are Vectorized Logical operator</li> </ul> </li> <li>The function\u00a0<code>which</code>\u00a0tells us which entries of a logical vector are TRUE</li> <li>The function <code>match</code> tells us which indexes of a second vector match each of the entries of a first vector</li> <li>If rather than an index we want a logical that tells us whether or not each element of a first vector is in a second, we can use the function\u00a0<code>%in%</code></li> </ul> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#basic-plots","title":"Basic Plots","text":"<ul> <li>Creating scatterplots with <code>plot</code>, histograms with <code>hist</code>, boxplots with <code>boxplot</code>, and image with <code>image</code></li> <li>The function <code>with</code> Evaluate an\u00a0R\u00a0expression in an environment constructed from data, possibly modifying (a copy of) the original data.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#3-programming-basic","title":"3. Programming Basic","text":"<ul> <li>Conditional expressions<ul> <li>R use if-else statement (like C language) for flow control</li> <li><code>ifelse</code> \u00a0takes three arguments: a logical and two possible answers. If the logical is\u00a0<code>TRUE</code>, the value in the second argument is returned and if\u00a0<code>FALSE</code>, the value in the third argument is returned</li> </ul> </li> <li>Defining functions<ul> <li>In general, functions are objects, so we assign them to variable names with\u00a0<code>&lt;-</code>. The function\u00a0<code>function</code>\u00a0tells R you are about to define a function. The general form of a function definition looks like this:</li> </ul> </li> </ul> S<pre><code>my_function &lt;- function(VARIABLE_NAME){\n    perform operations on VARIABLE_NAME and calculate VALUE\n    VALUE\n}\n</code></pre> <ul> <li>namespace: it is likely that two packages use the same name for two different functions<ul> <li>R will follow a certain order when searching for a function in these\u00a0namespaces. You can see the order by typing <code>search</code></li> <li>You can force the use of a specific namespace by using double colons (<code>::</code>) like: <code>dplyr::filter</code>, <code>stats::filter</code></li> <li>if we want to use a function in a package without loading the entire package, we can use the double colon as well</li> <li>If you want to see all the packages that have function called, for example\u00a0<code>filter</code>, you can use double questions marks:\u00a0<code>??filter</code></li> </ul> </li> <li>For-loops: the grammar is also like C language.</li> <li>Vectorization and functionals: vectorization\u00a0is preferred over for-loops<ul> <li>Functionals\u00a0are functions that help us apply the same function to each entry in a vector, matrix, data frame, or list. Here we cover the functional that operates on numeric, logical, and character vectors:\u00a0<code>sapply</code>.</li> </ul> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#4-the-tidyverse","title":"4. The tidyverse","text":"<ul> <li>Tidy format permits the data analyst to focus on more important aspects of the analysis rather than the format of the data</li> <li>Refining data frame:<ul> <li><code>mutate</code>: adding columns;  it takes the data frame as a first argument and the name and values of the variable as a second argument using the convention; transform variables, apply the same transformation to several variables by <code>across</code></li> <li><code>filter</code>: row-wise subsetting; it takes the data frame as the first argument and then a conditional statement as the second</li> <li><code>select</code>: column-wise subsetting;  it takes the data frame as a first argument and the column name as the next arguments (or <code>starts_with</code>, <code>where</code>, <code>ends_with</code>, <code>contains</code>, <code>matches</code>, <code>num_range</code>)</li> </ul> </li> <li>Pipe: perform a series of operations by <code>%&gt;%</code> or <code>|&gt;</code>; the pipe\u00a0sends\u00a0the result of the left side of the pipe to be the first argument of the function on the right side of the pipe</li> <li>The\u00a0<code>summarize</code>\u00a0function in\u00a0dplyr\u00a0provides a way to compute summary statistics</li> <li>A common operation in data exploration is to first split data into groups and then compute summaries for each group <code>group_by</code></li> <li>We can extract varialbes with\u00a0<code>pull</code></li> <li>With\u00a0<code>arrange</code>\u00a0we get to decide which column to sort by (also for nested sorting)</li> <li>The function <code>top_n</code> takes a data frame as it\u2019s first argument, the number of rows to show in the second, and the variable to filter by in the third. if the third argument is left blank,\u00a0<code>top_n</code>\u00a0filters by the last column.</li> <li>\u201ctibble\u201d, is a special kind of data frame, we can transform a data frame into a tibble by <code>as_tibble</code><ul> <li>Tibbles display better than data frame</li> <li>Tibbles can have complex entries (even functions)</li> <li>Tibbles can be grouped</li> <li>creating tibble;</li> </ul> </li> </ul> S<pre><code>grades_t &lt;- tibble(names = c(\"John\", \"Juan\", \"Jean\", \"Yao\"), \n                     exam_1 = c(95, 80, 90, 85), \n                     exam_2 = c(90, 85, 85, 90))\ngrades_d &lt;- data.frame(names = c(\"John\", \"Juan\", \"Jean\", \"Yao\"), \n                     exam_1 = c(95, 80, 90, 85), \n                     exam_2 = c(90, 85, 85, 90))\nas_tibble(grades_d) |&gt; class()\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n</code></pre> <ul> <li>Placeholder: if we want to pass it as argument to the right-hand side function that is not the first, we should use placeholder.<ul> <li>For <code>|&gt;</code> pipe the placeholder operator is\u00a0<code>_</code></li> <li>for the\u00a0<code>%&gt;%</code>\u00a0pipe the placeholder is\u00a0<code>.</code></li> </ul> </li> <li>purrr package: \u00a0includes functions similar to\u00a0<code>sapply</code>\u00a0but that better interact with other tidyverse functions<ul> <li><code>map</code> works very similar to\u00a0<code>sapply</code>\u00a0but always, without exception, returns a list</li> <li><code>map_dbl</code> always returns a vector of numeric values</li> <li><code>map_df</code>, always returns a tibble data frame</li> </ul> </li> <li> <p>Tidyverse conditionals:</p> <ul> <li>The\u00a0<code>case_when</code>\u00a0function is useful for vectorizing conditional statements. It is similar to\u00a0<code>ifelse</code>\u00a0but can output any number of values</li> </ul> S<pre><code>x &lt;- c(-2, -1, 0, 1, 2)\ncase_when(x &lt; 0 ~ \"Negative\", \n          x &gt; 0 ~ \"Positive\", \n          TRUE  ~ \"Zero\")\n#&gt; [1] \"Negative\" \"Negative\" \"Zero\"     \"Positive\" \"Positive\"\n</code></pre> <ul> <li><code>between</code> function determines if a value falls inside an interval.</li> </ul> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#5-datatable","title":"5. data.table","text":"<ul> <li>data.table is more efficient and can handle larger datasets more effectively.</li> <li>data.table\u00a0is a separate package that needs to be installed: <code>library(data.frame)</code></li> <li> <p>Refining data tables:</p> <ul> <li><code>as.data.table</code> can convert the data frame into a\u00a0data.table</li> <li>Column-wise subsetting:</li> </ul> S<pre><code>murders_dt[, c(\"state\", \"region\")] \nmurders_dt[, .(state, region)] \n</code></pre> </li> <li> <p>Adding or transformin variables: The\u00a0data.table <code>:=</code>\u00a0function permits us update the variable by reference</p> </li> </ul> S<pre><code>murders_dt[, rate := total / population * 100000]\nmurders_dt[, \":=\"(rate = total / population * 100000, rank = rank(population))]\n</code></pre> Text Only<pre><code>- **Reference versus copy**\n    - The\u00a0**data.table**\u00a0package is designed to avoid wasting memory: In `y &lt;- x` , `y` is referencing `x`; In `y &lt;- copy(x)`, `y` is the actual copy of `x`\n    - the function\u00a0`as.data.table`\u00a0creates a copy of the data frame being converted. However, if working with a large data frames it is helpful to avoid this by using\u00a0`setDT`:\n- **Row-wise subsetting**: `murders_dt[rate &lt;= 0.7, .(state, rate)]` has the same function as `murders |&gt; filter(rate &lt;= 0.7) |&gt; select(state, rate)`\n</code></pre> <ul> <li>Summarizing data: <code>s &lt;- heights |&gt; summarize(avg = mean(height), sd = sd(height))</code> has the same function as <code>s &lt;- heights_dt[, .(avg = mean(height), sd = sd(height))]</code><ul> <li>We simply add the\u00a0<code>by</code>\u00a0argument to split the data into groups based on the values in categorical variable <code>heights_dt[, .(avg = mean(height), sd = sd(height)), by = sex]</code></li> </ul> </li> <li>Sorting: <code>murders_dt[order(population)]</code></li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/01-R_Basics/#6-importing-data","title":"6. Importing data","text":"<ul> <li>highly recommend only using relative paths in your code</li> <li><code>getwd</code> get the full path of your working directory; <code>setwd</code> change your working directory; <code>file.path</code>\u00a0function combines characters to form a complete path; <code>file.copy</code> copy the file with full path;</li> <li>File types: text files and binary files<ul> <li>The most common delimiters are comma (<code>,</code>), semicolon (<code>;</code>), space (<code></code>), and tab (a preset number of spaces or\u00a0<code>\\t</code>);</li> <li>You can look at any number of lines from within R using the\u00a0<code>readLines</code>\u00a0function which can reveal what the file's delimited is.</li> <li>R\u2019s\u00a0<code>readBin</code>\u00a0function can process any binary file</li> <li>Encoding:\u00a0ASCII, UTF-8, UTF-16, and UTF-32; RStudio typically uses UTF-8 as its default</li> </ul> </li> <li>Parsers: importing functions are most in readr,\u00a0readxl and data.table packages.<ul> <li>Basic R: <code>read.csv</code>,\u00a0<code>read.table</code>\u00a0and\u00a0<code>read.delim</code>; <code>scan</code> is another flexible function</li> <li>readr: it is part of the\u00a0tidyverse; Its\u00a0parsers permit us to specify an encoding. It also includes a function <code>guess_encoding</code> that tries to guess the encoding; \u00a0we can specify it through the\u00a0<code>locale</code>\u00a0argument</li> <li>readxl: provides functions to read-in Microsoft Excel formats; These functions read the first sheet by default; The\u00a0<code>excel_sheets</code>\u00a0function gives us the names of all the sheets in an Excel file. These names can then be passed to the\u00a0<code>sheet</code>\u00a0argument in these functions.</li> <li>data.table: provides the\u00a0<code>fread</code>\u00a0function for large datasets which automatically detects the format of the input (even gzip and zip)</li> </ul> </li> </ul> Function Format Typical suffix <code>read_table</code> white space separated values txt <code>read_csv</code> comma separated values csv <code>read_csv2</code> semicolon separated values csv <code>read_tsv</code> tab delimited separated values tsv <code>read_delim</code> general text file format, must define delimiter txt Function Format Typical suffix read_excel auto detect the format xls, xlsx read_xls original format xls read_xlsx new format xlsx <ul> <li>Downloading files: Most parsers can read these files on the internet through url directly;<ul> <li>you can use the\u00a0<code>download.file</code>\u00a0function to have a local copy of the file;</li> <li><code>tempdir</code> creates a directory with a random name that is very likely to be unique;</li> <li><code>tempfile</code>\u00a0creates a character string, not a file, that is likely to be a unique filename</li> </ul> </li> <li>Organizing data with spreadsheets:<ul> <li>avoid Microsoft Excel format</li> <li>Be Consistent</li> <li>Choose Good Names for Things: don't use space and symbols; stick to letters and numbers</li> <li>Write Dates as YYYY-MM-DD</li> <li>No Empty Cells</li> <li>Put Just One Thing in a Cell</li> <li>Make It a Rectangle</li> <li>Create a Data Dictionary</li> <li>No Calculations in the Raw Data Files</li> <li>Do Not Use Font Color or Highlighting as Data</li> <li>Make Backups</li> <li>Use Data Validation to Avoid Errors</li> <li>Save the Data as Text Files</li> </ul> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/","title":"Visualization","text":"<p>\u201cThe greatest value of a picture is when it forces us to notice what we never expected to see.\u201d -- John W. Tukey</p> <p>Tools for data visualization:</p> scene Package basics data visualization ggplot2, lattice, grid interactive plots plotly, Shiny more advanced challenges D3.js"},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#7-visualizing-data-distributions","title":"7. Visualizing data distributions","text":"<ul> <li>Variable types: categorical (ordinal or not) and numeric (discrete or continuous)<ul> <li>discrete numeric data can be considered ordinal</li> </ul> </li> <li>Distributions:<ol> <li>empirical cumulative distribution function (eCDF)</li> <li>histograms</li> <li>smooth density\u00a0plots: make it easier to compare two distributions</li> <li>normal distribution: use mean and standard deviation to describe the distribution.</li> </ol> </li> <li>Boxplots: provides a five-number summary composed of the range (the minimum and maximum) along with the\u00a0quartiles\u00a0(the 25th, 50th, and 75th percentiles)</li> <li>stratification: Dividing observations into groups based on the values of one or more variables associated with those observations.<ul> <li>the resulting groups is\u00a0strata.</li> </ul> </li> <li>quantile:\u00a0are cutoff points that divide a dataset into intervals with set probabilities <code>quantile(data, q)</code></li> <li><code>pnorm(a, avg, s)</code>\u00a0gives the value of the cumulative distribution function\u00a0\u00a0for the normal distribution defined by average\u00a0<code>avg</code>\u00a0and standard deviation\u00a0<code>s</code>.</li> <li>Quantile-quantile plots, or QQ-plots, are used to check whether distributions are well-approximated by a normal distribution.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#8-ggplot2","title":"8. ggplot2","text":"<ul> <li>benifit: easy for beginners; more intuitive for beginners (it uses a grammar of graphics)</li> <li>limitation: work exclusively with data tables in tidy format.</li> <li>ggplot2\u00a0consists of some components<ol> <li>Data</li> <li>Geometry</li> <li>Aesthetic mapping</li> </ol> </li> </ul> <p>DATA |&gt;\u00a0ggplot() + LAYER 1 + LAYER 2 + \u2026 + LAYER N</p> <ul> <li>Packages: ggplot2, ggthemes, ggrepel</li> <li>some functions in ggplot2:<ul> <li>barplots: <code>geom_bar</code></li> <li>histograms: <code>geo_histogram</code></li> <li>density plots: <code>geo_density</code></li> <li>boxplots: <code>geo_boxplot</code></li> <li>images: <code>geom_tile</code>\u00a0and\u00a0<code>geom_raster</code></li> </ul> </li> </ul> <p>ggplot2 cheatsheet pdf </p> S<pre><code>library(ggthemes)\nlibrary(ggrepel)\n\nr &lt;- murders |&gt; \n  summarize(rate = sum(total) /  sum(population) * 10^6) |&gt;\n  pull(rate)\n\nmurders |&gt; \n  ggplot(aes(population/10^6, total)) +   \n  geom_abline(intercept = log10(r), lty = 2, color = \"darkgrey\") +\n  geom_point(aes(col = region), size = 3) +\n  geom_text_repel(aes(label = abb)) + \n  scale_x_log10() +\n  scale_y_log10() +\n  labs(title = \"US Gun Murders in 2010\",\n                x = \"Populations in millions (log scale)\", \n                y = \"Total number of murders (log scale)\",\n                color = \"Region\") +\n  theme_economist()\n</code></pre>"},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#9-data-visualization-principles","title":"9. Data visualization principles","text":"<ul> <li>Encoding data using visual cues: position, aligned lengths, angles, area, brightness, color hue<ul> <li>In general, when displaying quantities, position and length are preferred over angles and/or area. Brightness and color are even harder to quantify than angles.</li> <li>But they are sometimes useful when more than two dimensions must be displayed at once.</li> </ul> </li> <li>Know when to include 0<ul> <li>When using length as a visual cue, it is misinformative not to start the bars at 0.</li> <li>When using position rather than length, it is then not necessary to include 0</li> </ul> </li> <li>Do not distort quantities</li> <li>Order categories by a meaningful value</li> <li>Show the data</li> </ul> S<pre><code># dot plot showing the data\nheights %&gt;% ggplot(aes(sex, height)) + geom_point() \n# jittered, alpha blended point plot \nheights %&gt;% ggplot(aes(sex, height)) + geom_jitter(width = 0.1, alpha = 0.2)\n</code></pre> <ul> <li>Ease comparisons<ul> <li>Use common axes</li> <li>Aligning plots for comparisons</li> </ul> </li> <li>Transformations<ul> <li>log transformation</li> <li>logistic transformation</li> <li>square root transformation</li> </ul> </li> <li>Visual cues to be compared should be adjacent</li> <li>Think of the color blind</li> </ul> S<pre><code>color_blind_friendly_cols &lt;- c(\"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\") \np1 &lt;- data.frame(x = 1:8, y = 1:8, col = as.character(1:8)) %&gt;%  \n    ggplot(aes(x, y, color = col)) +  \n    geom_point(size = 5)  \np1 + scale_color_manual(values = color_blind_friendly_cols)\n</code></pre> <ul> <li>Plots for two variables<ul> <li>Slope charts</li> <li>Bland-Altman plot</li> </ul> </li> <li>Encoding a third variable<ul> <li>We encode categorical variables with color and shape.</li> <li>For continuous variables, we can use color, intensity, or size.</li> </ul> </li> <li>Avoid pseudo-three-dimensional plots</li> <li>Avoid too many significant digits: <code>options(digits = 3)</code></li> <li>Know your audience<ol> <li>for our own exploratory data analysis</li> <li>to convey a message to experts</li> <li>to help convey a message to a general audience</li> </ol> </li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#10-data-visualization-in-practice","title":"10\u00a0\u00a0Data visualization in practice","text":""},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#case-study-1","title":"Case Study 1","text":""},{"location":"notes/ai/Harvard-Data-Science/02-Visualization/#case-study-2","title":"Case Study 2","text":"<ul> <li>Logistic transformation: \\(f(p)=\\log(\\frac{p}{1-p})\\): This scale is useful when we want to highlight differences near 0 or 1</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/","title":"Probability","text":"<p>This part discusses concepts of probability, and uses R to demonstrate these concepts.</p>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#1-discrete-probability","title":"1. Discrete probability","text":"<p>The most important thing in this chapter is to learn how to calculate probabilities and use Monte Carlo simulations.</p> <p>Event: refer to things that can happen when something occurs by chance.</p> <p>Distribution: We simply assign a probability to each category. their proportion defines the distribution.</p> <p>Monte Carlo</p> S<pre><code># Setting the random seed\nset.seed(1986)\n# rep to generate the\nbeads &lt;- rep(c(\"red\", \"blue\"), times = c(2,3))\nB &lt;- 10000\n# repeat the same task any number of times.\nevents &lt;- replicate(B, sample(beads, 1))\n# use table to see the distribution\ntab &lt;- table(events)\n# prop.table gives the proportions\nprop.table(tab)\n\nevents &lt;- sample(beads, B, replace = TRUE)\n</code></pre> <p>Seed: A popular way to pick the seed is the year - month - day</p> <p><code>sample</code> selects elements\u00a0without replacement by default. We can change the <code>replace</code> argument to <code>replace=TRUE</code> for selects elements\u00a0with replacement</p> <p>Independent: two events are independent if the outcome of one does not affect the other</p> <p>Multiplication rule:</p> \\[ \\mbox{Pr}(A \\mbox{ and } B) = \\mbox{Pr}(A)\\mbox{Pr}(B \\mid A) \\] <p>Addition rule:</p> \\[ \\mbox{Pr}(A \\mbox{ or } B) = \\mbox{Pr}(A) + \\mbox{Pr}(B) - \\mbox{Pr}(A \\mbox{ and } B) \\] <p>Combinations and permutations: <code>combinations</code> and <code>permutations</code> in library <code>gtools</code></p>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#example","title":"Example","text":""},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#1-natural-21-in-blackjack","title":"1. Natural 21\u00a0in Blackjack","text":"<p>Two ways to estimate the probablity: 1. Caculate directly</p> S<pre><code>library(gtools)\n\nsuits &lt;- c(\"Diamonds\", \"Clubs\", \"Hearts\", \"Spades\")\nnumbers &lt;- c(\"Ace\", \"Deuce\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \n             \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\")\ndeck &lt;- expand.grid(number = numbers, suit = suits)\ndeck &lt;- paste(deck$number, deck$suit)\n\nhands &lt;- permutations(52, 2, v = deck)\nfirst_card &lt;- hands[,1]\nsecond_card &lt;- hands[,2]\n\naces &lt;- paste(\"Ace\", suits)\n\nfacecard &lt;- c(\"King\", \"Queen\", \"Jack\", \"Ten\")\nfacecard &lt;- expand.grid(number = facecard, suit = suits)\nfacecard &lt;- paste(facecard$number, facecard$suit)\n\nhands &lt;- combinations(52, 2, v = deck)\nmean(hands[,1] %in% aces &amp; hands[,2] %in% facecard)\n</code></pre> <ol> <li>Monte Carlo simulation</li> </ol> S<pre><code>hand &lt;- sample(deck, 2) \n\nblackjack &lt;- function(){\n   hand &lt;- sample(deck, 2)\n  (hand[1] %in% aces &amp; hand[2] %in% facecard) | \n    (hand[2] %in% aces &amp; hand[1] %in% facecard)\n}\n\nB &lt;- 10000\nresults &lt;- replicate(B, blackjack())\nmean(results)\n</code></pre>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#2-monty-hall-problem","title":"2. Monty Hall problem","text":"S<pre><code>B &lt;- 10000\nmonty_hall &lt;- function(strategy){\n  doors &lt;- as.character(1:3)\n  prize &lt;- sample(c(\"car\", \"goat\", \"goat\"))\n  prize_door &lt;- doors[prize == \"car\"]\n  my_pick  &lt;- sample(doors, 1)\n  show &lt;- sample(doors[!doors %in% c(my_pick, prize_door)],1)\n  stick &lt;- my_pick\n  stick == prize_door\n  switch &lt;- doors[!doors %in% c(my_pick, show)]\n  choice &lt;- ifelse(strategy == \"stick\", stick, switch)\n  choice == prize_door\n}\nstick &lt;- replicate(B, monty_hall(\"stick\"))\nmean(stick)\n#&gt; [1] 0.342\nswitch &lt;- replicate(B, monty_hall(\"switch\"))\nmean(switch)\n#&gt; [1] 0.668\n</code></pre>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#3-birthday-problem","title":"3. Birthday problem","text":"<p>Monte Carlo simulation</p> S<pre><code>B &lt;- 10000\n\nsame_birthday &lt;- function(n){\n  bdays &lt;- sample(1:365, n, replace = TRUE)\n  any(duplicated(bdays))\n}\n\ncompute_prob &lt;- function(n, B = 10000){\n  results &lt;- replicate(B, same_birthday(n))\n  mean(results)\n}\n\nn &lt;- seq(1,60)\nprob &lt;- sapply(n, compute_prob)\n</code></pre> <p>Real probability</p> \\[ 1 \\times \\frac{364}{365}\\times\\frac{363}{365} \\dots \\frac{365-n + 1}{365} \\] S<pre><code>exact_prob &lt;- function(n){\n  prob_unique &lt;- seq(365, 365 - n + 1)/365 \n  1 - prod( prob_unique)\n}\neprob &lt;- sapply(n, exact_prob)\nqplot(n, prob) + geom_line(aes(n, eprob), col = \"red\")\n</code></pre> <p></p> <p>the larger the\u00a0B, the better the approximation How to determine the B?</p> <ul> <li>One practical approach is to check for the stability of the estimate.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#2-continuous-probability","title":"2. Continuous probability","text":"<p>In this chapter, we should know the concept of: Cumulative distribution functions, Probability density function</p> <p>R uses a convention that lets us remember the names, namely using the letters\u00a0<code>d</code> (density function),\u00a0<code>q</code> (quantile function),\u00a0<code>p</code> (distribution function), and\u00a0<code>r</code> (random generation)\u00a0in front of a shorthand for the distribution. (e.g. <code>dnorm</code>, <code>qnorm</code>, <code>pnorm</code>, <code>rnorm</code>)</p> <p>A simple chapter~</p>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#3-random-variables","title":"3. Random variables","text":"<p>Central Limit Theorem: when the number of draws, also called the\u00a0sample size, is large, the probability distribution of the sum of the independent draws is approximately normal.</p> <p>Using the CLT, we can skip the Monte Carlo simulation</p> \\[ \\begin{aligned} E(\\frac{X_1+X_2+...X_n}{n}) &amp;= n\\mu/n =\\mu \\\\ \\sigma(\\frac{X_1+X_2+...X_n}{n}) &amp;= \\frac{\\sigma}{\\sqrt{n}} \\end{aligned} \\] <p>Law of large numbers: the standard error of the average becomes smaller and smaller as\u00a0sample size\u00a0grows larger.</p>"},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#4-the-big-short","title":"4. The Big Short","text":""},{"location":"notes/ai/Harvard-Data-Science/03-Probability/#equations-calculating-interest-rate-for-1-probability-of-losing-money","title":"Equations: Calculating interest rate for 1% probability of losing money","text":"<p>We want to calculate the value of\u00a0\\(x\\)\u00a0for which\u00a0\\(\\mathrm{Pr}(S&lt;0)=0.01\\). The expected value\u00a0\\(E[S]\\)\u00a0of the sum of\u00a0\\(n=1000\\)\u00a0loans given our definitions of\u00a0\\(x\\),\u00a0\u00a0\\(l\\) and\u00a0\\(p\\)\u00a0is:</p> \\[ \\mu_S=(lp+x(1-p))* n \\] <p>And the standard error of the sum of\u00a0\\(n\\)\u00a0loans,\u00a0\\(\\mathrm{SE}[S]\\), is:</p> \\[ \\sigma_S=\\left\\vert x-l \\right\\vert\\sqrt{np(1-p)} \\] <p>Because we know the definition of a Z-score is\u00a0\\(Z=\\dfrac{x-\\mu}{\\sigma}\\), we know that\u00a0\\(\\mathrm{Pr}(S&lt;0)=\\mathrm{Pr}(Z&lt;-\\dfrac{\\mu}{\\sigma})\\). Thus,\u00a0\\(\\mathrm{Pr}(S&lt;0)=0.01\\)\u00a0equals:</p> \\[ \\mathrm{Pr}(Z&lt;\\frac{-\\{lp+x(1-x)\\}n}{(x-l)\\sqrt{np(1-p)}}) \\] <p><code>z&lt;-qnorm(0.01)</code>\u00a0gives us the value of\u00a0\\(z\\)\u00a0for which\u00a0\\(\\mathrm{Pr}(Z\\leq z)=0.01\\), meaning:</p> \\[ z = \\frac{-\\{lp+x(1-x)\\}n}{(x-l)\\sqrt{np(1-p)}} \\] <p>Solving for\u00a0\u00a0gives:</p> \\[ x = -l\\frac{np-z\\sqrt{np(1-p)}}{n(1-p)+z\\sqrt{np(1-p)}} \\]"},{"location":"notes/ai/Harvard-Data-Science/04-Inference_and_Modeling/","title":"Inference and Modeling","text":""},{"location":"notes/ai/Harvard-Data-Science/04-Inference_and_Modeling/#1-parameters-and-estimates","title":"1. Parameters and Estimates","text":"<p>Parameters: we define\u00a0parameters\u00a0to represent unknown parts of our models.</p>"},{"location":"notes/ai/Harvard-Data-Science/04-Inference_and_Modeling/#4-hypothesis-testing","title":"4. Hypothesis testing","text":"<p>p_value: We have observed a random variable\u00a0X\u00af=0.52, and the p-value is the answer to the question: How likely is it to see a value this large, when the null hypothesis is true? If the p-value is small enough, we\u00a0reject the null hypothesis\u00a0and say that the results are\u00a0statistically significant. (The p-value is the probability of observing a value as extreme or more extreme than the result given that the null hypothesis is true.)</p> <p>Power: power\u00a0is the probability of detecting spreads different from 0.</p>"},{"location":"notes/ai/Harvard-Data-Science/04-Inference_and_Modeling/#6-data-driven-models","title":"6. Data-driven models","text":"<p><code>map_df</code> v. s. <code>sapply</code>:</p> <p>In R programming, <code>map_df</code> and <code>sapply</code> are both functions used for applying a function to each element of a vector or list, but they have some key differences:</p> <ol> <li>Output Type:<ul> <li><code>map_df</code>\u00a0from the\u00a0purrr\u00a0package (part of the\u00a0tidyverse) applies a function to each element of a vector or list and then combines the results into a single data frame. It is specifically designed to work with data frames and tibbles.</li> <li><code>sapply</code>\u00a0applies a function to each element of a vector or list and returns a matrix, a higher-dimensional array, or a list, depending on the input and the nature of the function applied.</li> </ul> </li> <li>Default Data Structure:<ul> <li><code>map_df</code>\u00a0always returns a data frame (or a tibble, which is a modern version of a data frame).</li> <li><code>sapply</code>\u00a0returns a matrix or an array if possible, otherwise it returns a list.</li> </ul> </li> <li>Performance:<ul> <li><code>map_df</code>\u00a0is often easier to use with non-standard evaluation and can be more readable when working with data frames.</li> <li><code>sapply</code>\u00a0can be faster in some cases because it is optimized for matrix operations, but it might require more manual handling of the output structure.</li> </ul> </li> <li>Ease of Use:<ul> <li><code>map_df</code>\u00a0is part of the\u00a0tidyverse, which promotes a consistent and easy-to-understand syntax for data manipulation.</li> <li><code>sapply</code>\u00a0is a base R function, and while it is very powerful, it might require more effort to handle the output in a tidy data frame format.</li> </ul> </li> </ol>"},{"location":"notes/ai/Harvard-Data-Science/04-Inference_and_Modeling/#8-hierarchical-models","title":"8. Hierarchical Models","text":"<p>A key difference between the Bayesian and the Frequentist hierarchical model approach is that, in the latter, we use data to construct priors rather than treat priors as a quantification of prior expert knowledge.</p>"},{"location":"notes/ai/Harvard-Data-Science/05-Productivity_Tools/","title":"Productivity Tools","text":"<p>Read the book directly Introduction to Data Science - Productivity Tools (harvard.edu)</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/","title":"Wrangling","text":""},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#0-importing-data","title":"0. Importing data","text":"<p>See in R basics</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#1-reshaping-data","title":"1. Reshaping data","text":""},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#tidyverse","title":"tidyverse","text":"<p><code>pivot_longer</code>: \u00a0convert wide data into long (tidy) data</p> <p><code>pivot_wider</code>: \u00a0convert long (tidy) data into wide data</p> <p><code>separate_wider_delim</code>, <code>separate_wider_position</code>, <code>separate_wider_regex</code>, <code>separate</code>: separate these columns into two or more</p> <p><code>unite</code>:\u00a0paste together multiple columns into one</p> <p><code>clean_names</code>: Resulting names are unique and consist only of the _ character, numbers, and letters.</p> <p><code>column_to_rownames</code>: convert an explicit column to row name.</p> <p><code>row_to_names</code>: Elevate a row to be the column names of a data.frame.</p> <p><code>get_dupes</code>: For hunting duplicate records during data cleaning. Specify the data.frame and the variable combination to search for duplicates and get back the duplicated rows.</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#datatable","title":"data.table","text":"<p><code>melt</code>: convert wide data into long data.</p> <p><code>dcast</code>: convert long data into wide data.</p> <p><code>tstrsplit</code>: This is a convenient wrapper function to split a column using\u00a0<code>strsplit</code>\u00a0and assign the transposed result to individual columns.</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#2-joining-tables","title":"2. Joining tables","text":""},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#joins","title":"Joins","text":"<p><code>left_join</code>, <code>right_join</code>, <code>inner_join</code>, <code>full_join</code>, <code>semi_join</code>, <code>anti_join</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#binding","title":"Binding","text":"<p>Binding columns: <code>bind_cols</code>, <code>cbind</code> (<code>cbind</code>\u00a0can create different types of objects, while\u00a0<code>bind_cols</code>\u00a0always produces a data frame.)</p> <p>Binding by rows: <code>bind_rows</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#set-operators","title":"Set operators","text":"<p><code>intersect</code>, <code>union</code>, <code>setdiff</code>, <code>setequal</code></p> <p><code>dplyr::intersect</code>, <code>dplyr::union</code>, <code>dplyr::setdiff</code>, <code>dplyr::setequal</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#joining-with-datatable","title":"Joining with data.table","text":"<p><code>merge</code>\u00a0uses the the logical arguments\u00a0<code>all</code>\u00a0(full join),\u00a0<code>all.x</code>\u00a0(left join), and\u00a0<code>all.y</code>\u00a0(right join).</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#3-parsing-dates-and-times","title":"3. Parsing dates and times","text":""},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#lubridate","title":"lubridate","text":"<p>extract values: <code>year</code>,\u00a0<code>month</code>\u00a0and\u00a0<code>day</code></p> <p>convert strings into dates: <code>ymd</code>,<code>ydm</code>, <code>mdy</code>, <code>myd</code>, <code>dmy</code>, <code>dym</code>, <code>yq</code>, <code>ym</code>, <code>my</code></p> <p>get the current time: <code>now</code></p> <p>create a date object: <code>make_date</code></p> <p>round\u00a0dates to nearest year, quarter, month, week, day, hour, minutes, or seconds: <code>round_date</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#datatable_1","title":"data.table","text":"<p><code>second</code>,\u00a0<code>minute</code>,\u00a0<code>hour</code>,\u00a0<code>yday</code>,\u00a0<code>wday</code>,\u00a0<code>week</code>,\u00a0<code>isoweek</code>\u00a0and\u00a0<code>quarter</code></p> <p><code>IDate</code>\u00a0and\u00a0<code>ITime</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#4-locales","title":"4. Locales","text":"<p>access or change the current locale settings: <code>Sys.getlocale</code> and <code>Sys.setlocale</code></p> <ul> <li><code>LC_ALL</code>: \u00a0all locale categories</li> <li><code>LC_COLLATE</code>: for string collation</li> <li><code>LC_TIME</code>: date and time formatting</li> <li><code>LC_MONETARY</code>: currency formatting.</li> <li><code>LC_MESSAGES</code>: system message translations.</li> <li><code>LC_NUMERIC</code>: number formatting.</li> </ul> <p><code>locale()</code> in readr  can change the current locale from within R</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#5-extracting-data-from-the-web","title":"5. Extracting data from the web","text":""},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#scraping-html","title":"Scraping HTML","text":"<p>rvest package: import the webpage into R. <code>read_html</code>, <code>html_text</code>, <code>html_nodes</code>, <code>html_table</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#json","title":"JSON","text":"<p>jsonlite\u00a0package: <code>fromJSON</code> read JSON file also you can choose rjson</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#data-apis","title":"Data APIs","text":"<p>httr2 package: <code>request</code>, <code>req_perform</code>, <code>resp_body_string</code>, <code>read_csv</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#6-string-processing","title":"6.  String processing","text":"stringr Task Description Base R <code>str_detect</code> Detect Is the pattern in the string? <code>grepl</code> <code>str_which</code> Detect Returns the index of entries that contain the pattern. <code>grep</code> <code>str_subset</code> Detect Returns the subset of strings that contain the pattern. <code>grep</code>\u00a0with\u00a0<code>value = TRUE</code> <code>str_locate</code> Locate Returns positions of first occurrence of the pattern in a string. <code>regexpr</code> <code>str_locate_all</code> Locate Returns position of all occurrences of the pattern in a string. <code>gregexpr</code> <code>str_view</code> Locate Show the first part of the string that matches the pattern. <code>str_view_all</code> Locate Show all the parts of the string that match the pattern. <code>str_extract</code> Extract Extract the first part of the string that matches the pattern. <code>str_extract_all</code> Extract Extract all parts of the string that match the pattern. <code>str_match</code> Extract Extract first part of the string that matches the pattern and the groups defined by the pattern. <code>str_match_all</code> Extract Extract all parts of the string that match the pattern and the groups defined by the pattern. <code>str_sub</code> Extract Extract a substring. <code>substring</code> <code>str_split</code> Extract Split a string into a list with parts separated by a pattern. <code>strsplit</code> <code>str_split_fixed</code> Extract Split a string into a matrix with a fixed number of parts separated by a pattern. <code>strsplit</code>\u00a0with\u00a0<code>fixed = TRUE</code> <code>str_count</code> Describe Count number of times a pattern appears in a string. <code>str_length</code> Describe Number of character in string. <code>nchar</code> <code>str_replace</code> Replace Replace first part of a string matching a pattern with another. <code>str_replace_all</code> Replace Replace all parts of a string matching a pattern with another. <code>gsub</code> <code>str_to_upper</code> Replace Change all characters to upper case. <code>toupper</code> <code>str_to_lower</code> Replace Change all characters to lower case. <code>tolower</code> <code>str_to_title</code> Replace Change first character of each word to upper and rest to lower case. <code>str_replace_na</code> Replace Replace all\u00a0<code>NA</code>s with a new value. <code>str_trim</code> Replace Remove white space from start and end of string. <code>str_c</code> Manipulate Join multiple strings. <code>paste0</code> <code>str_conv</code> Manipulate Change the encoding of the string. <code>str_sort</code> Manipulate Sort the vector in alphabetical order. <code>sort</code> <code>str_order</code> Manipulate Provide index needed to order the vector in alphabetical order. <code>order</code> <code>str_trunc</code> Manipulate Truncate a string to a fixed size. <code>str_pad</code> Manipulate Add white space to string to make it a fixed size. <code>str_dup</code> Manipulate Repeat a string. <code>rep</code>\u00a0then\u00a0<code>paste</code> <code>str_wrap</code> Manipulate Wrap things into formatted paragraphs. <code>str_interp</code> Manipulate String interpolation. <code>sprintf</code> <p><code>suppressWarnings</code>: avoid the warning message</p> <p><code>cat</code>\u00a0lets us see what the string actually looks like</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#escaping-characters","title":"Escaping characters","text":"<p>Characters are typically escaped by placing a backslash <code>\\</code> before them.</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#regular-expressions","title":"Regular expressions","text":"<p>A regular expression (regex) is a way to describe specific patterns of characters of text. They can be used to determine if a given string matches the pattern. Tutorial</p> <p>Strings are a regex</p> <p>Special characters</p> <ul> <li><code>\\d</code>\u00a0means any digit: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.</li> <li><code>|</code> means\u00a0or in a pattern</li> <li><code>\\w</code>\u00a0which stands for\u00a0word character\u00a0and it matches any letter, number, or underscore.</li> </ul> <p>Character classes</p> <ul> <li>Character classes are used to define a series of characters that can be matched. We define character classes with square brackets\u00a0<code>[]</code></li> <li>we can define lower case letters as\u00a0<code>[a-z]</code>, upper case letters as\u00a0<code>[A-Z]</code>, and\u00a0<code>[a-zA-Z]</code>\u00a0as both.</li> <li><code>\\w</code>\u00a0is equivalent to\u00a0<code>[a-zA-Z0-9_]</code>.</li> </ul> <p>Anchors: \u00a0let us define patterns that must start or end at a specific place</p> <ul> <li>The two most common anchors are\u00a0<code>^</code>\u00a0and\u00a0<code>$</code>\u00a0which represent the beginning and end of a string</li> </ul> <p>Bounded quantifiers: following the pattern with curly brackets containing the number of times the previous entry can be repeated</p> <p>White space: <code>\\s</code>\u00a0represents white space</p> <p>Unbounded quantifiers: <code>*</code>, <code>?</code>, <code>+</code> </p> Usage Unbounded quantifiers none or once <code>?</code> once or more <code>+</code> none or more <code>*</code> <p>Not: </p> <ul> <li>we can use the\u00a0<code>^</code>\u00a0symbol but only\u00a0inside\u00a0square brackets. Remember that outside the square bracket\u00a0<code>^</code>\u00a0means the start of the string.</li> <li><code>\\D</code>\u00a0means anything other than a digit</li> <li><code>\\S</code>\u00a0means anything except a space</li> </ul> <p>Groups: Groups\u00a0are a powerful aspect of regex that permits the extraction of values. Groups are defined using parentheses. They don\u2019t affect the pattern matching per se. Instead, it permits tools to identify specific parts of the pattern so we can extract them.</p> <p>Search and replace using groups: The regex special character for the\u00a0<code>i</code>-th group is\u00a0<code>\\\\i</code></p> <p>Lookarounds: Lookarounds provide a way to ask for one or more conditions to be satisfied without moving the search forward or matching it.</p> <p>- lookahead\u00a0<code>(?=pattern)</code> \u00a0- lookbehind\u00a0<code>(?&lt;=pattern)</code> \u00a0- negative lookahead\u00a0<code>(?!pattern)</code> \u00a0-  negative lookbehind\u00a0<code>(?&lt;!pattern)</code></p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#trimming","title":"Trimming","text":"<p><code>str_trim</code>: remove the space at the start or end of the string</p>"},{"location":"notes/ai/Harvard-Data-Science/06-Wrangling/#case-conversion","title":"Case conversion","text":"<ul> <li><code>str_to_upper()</code>\u00a0converts to upper case.</li> <li><code>str_to_lower()</code>\u00a0converts to lower case.</li> <li><code>str_to_title()</code>\u00a0converts to title case, where only the first letter of each word is capitalized.</li> <li><code>str_to_sentence()</code>\u00a0convert to sentence case, where only the first letter of sentence is capitalized.</li> </ul>"},{"location":"notes/ai/Harvard-Data-Science/07-Linear_Regression/","title":"Linear Regression","text":""},{"location":"notes/ai/Harvard-Data-Science/08-Machine_Learning/","title":"Machine Learning","text":""},{"location":"notes/ai/Harvard-Data-Science/09-Capstone/","title":"Capstone","text":""},{"location":"notes/algorithms/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/architecture/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/databases/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/distributed-systems/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/intro/CrashCourseCS/","title":"CrashCourseCS","text":"<p>Notes for Cash Course: Computer Science</p>"},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/","title":"Computer Science Crash Course","text":"<p>Here are my notes for Crash Course Computer Science's important concepts.</p>"},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#0-crash-course-computer-science-preview","title":"0. Crash Course Computer Science Preview","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#1-early-computing","title":"1. Early Computing","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#2-electronic-computing","title":"2. Electronic Computing","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#3-boolean-logic-logic-gates","title":"3. Boolean Logic &amp; Logic Gates","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#4-representing-numbers-and-letters-with-binary","title":"4. Representing Numbers and Letters with Binary","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#5-how-computers-calculate-the-alu","title":"5. How Computers Calculate \u2013 the ALU","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#6-registers-and-ram","title":"6. Registers and RAM","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#7-the-central-processing-unit-cpu","title":"7. The Central Processing Unit (CPU)","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#8-instructions-programs","title":"8. Instructions &amp; Programs","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#9-advanced-cpu-designs","title":"9. Advanced CPU Designs","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#10-early-programming","title":"10. Early Programming","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#11-the-first-programming-languages","title":"11. The First Programming Languages","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#12-programming-basics-statements-functions","title":"12. Programming Basics \u2013 Statements &amp; Functions","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#13-intro-to-algorithms","title":"13. Intro to Algorithms","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#14-data-structures","title":"14. Data Structures","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#15-alan-turing","title":"15. Alan Turing","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#16-software-engineering","title":"16. Software Engineering","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#17-integrated-circuits-moores-law","title":"17. Integrated Circuits &amp; Moore\u2019s Law","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#18-operating-systems","title":"18. Operating Systems","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#19-memory-storage","title":"19. Memory &amp; Storage","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#20-files-file-systems","title":"20. Files &amp; File Systems","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#21-compression","title":"21. Compression","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#22-keyboards-command-line-interfaces","title":"22. Keyboards &amp; Command Line Interfaces","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#23-screens-2d-graphics","title":"23. Screens &amp; 2D Graphics","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#24-the-cold-war-and-consumerism","title":"24. The Cold War and Consumerism","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#25-the-personal-computer-revolution","title":"25. The Personal Computer Revolution","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#26-graphical-user-interfaces","title":"26. Graphical User Interfaces","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#27-3d-graphics","title":"27. 3D Graphics","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#28-computer-networks","title":"28. Computer Networks","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#29-the-internet","title":"29. The Internet","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#30-the-world-wide-web","title":"30. The World Wide Web","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#31-cybersecurity","title":"31. Cybersecurity","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#32-hackers-cyber-attacks","title":"32. Hackers &amp; Cyber Attacks","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#33-cryptography","title":"33. Cryptography","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#34-machine-learning-artificial-intelligence","title":"34. Machine Learning &amp; Artificial Intelligence","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#35-computer-vision","title":"35. Computer Vision","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#36-natural-language-processing","title":"36. Natural Language Processing","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#37-robots","title":"37. Robots","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#38-psychology-of-computing","title":"38. Psychology of Computing","text":""},{"location":"notes/intro/CrashCourseCS/CrashCourseCS/#39-educational-technology","title":"39. Educational Technology","text":""},{"location":"notes/languages/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/math/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/networking/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/operating-systems/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/others/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"notes/programming/templates/","title":"TODO","text":"<p>The content needs further refinement.</p>"},{"location":"resources/ai/","title":"Artificial Intelligence","text":"Subject Book Course Video Artificial Intelligence Artificial Intelligence: A Modern Approach Berkeley's CS188: Introduction to Artificial Intelligence Fall 2018              Bilibili Youtube Harvard CS50: Introduction to AI with Python              Bilibili Youtube Data Science Introduction to Data Science: Data Wrangling and Visualization with R Statistics and Prediction Algorithms Through Case Studies Harvard CS109: Data Science              Bilibili Computational and Inferential Thinking: The Foundations of Data Science UCB Data8: The Foundations of Data Science Spring 2022              Youtube Learning Data Science UCB Data100: Principles and Techniques of Data Science Spring 2024              Youtube Machine Learning Machine Learning Specialization Bilibili Youtube An Introduction to Statistical Learning with Python Stanford Statistical Learning Bilibili Youtube Learning From Data Caltech CS156: Machine Learning              Bilibili Youtube Stanford CS229: Machine Learning              Bilibili Youtube Deep Learning Foundations and Concepts UCB CS189: Introduction to Machine Learning Spring 2024              Bilibili CMU 10-414/714: Deep Learning Systems              Official Machine Learning Compilation Machine Learning Compilation Bilibili Youtube Deep Learning Deep Learning Specialization Bilibili                 Youtube                 1,                  2,                  3,                  4,                  5 CS231N: CNN for Visual Recognition (Spring 2017)              Bilibili Youtube CS224N: Natural Language Processing (Winter 2023)              Bilibili Youtube CS224W: Machine Learning with Graphs (Fall 2021)              Bilibili Youtube Deep Learning UMich EECS 498-007 / 598-005: Deep Learning for Computer Vision (Fall 2019)              Bilibili Youtube UCB CS285: Deep Reinforcement Learning (Fall 2023)              Bilibili Youtube Further Learning Pattern Recognition and Machine Learning MIT 6.867: Machine Learning              All of statistics CMU 36-705: Intermediate Statistics              Youtube Convex Optimization EE364A Convex Optimization \u2160 EE364B Convex Optimization \u2161              Bilibili Youtube Probabilistic Machine Learning The Elements of Statistical Learning CMU 10-708: Probabilistic Graphical Models Bilibili Youtube Columbia STAT 8201: Deep Generative Models              U Toronto STA 4273: Minimizing Expectations              Stanford CS229M: Machine Learning Theory              Bilibili Youtube"},{"location":"resources/algorithms/","title":"Algorithms and Data Structures","text":"Book Course Video The Algorithm Design Manual Steven Skiena's CSE 373: Analysis of Algorithms              Bilibili Youtube Algorithms Illuminated Stanford CS161: Design and Analysis of Algorithms              Bilibili Youtube Coursera Introduction to Algorithms MIT 6.006: Introduction to Algorithms              Bilibili Youtube Algorithms Princeton COS226: Algorithms              Bilibili Youtube                 Coursera                  1,                  2"},{"location":"resources/architecture/","title":"Computer Architecture","text":"Book Course Video Computer Systems: A Programmer's Perspective UCB CS61C: Great Ideas in Computer Architecture                               Fall 2020:  Bilibili Youtube                  Spring 2015:  Bilibili Youtube CMU CS15213: Introduction to Computer Systems              Bilibili Youtube The Elements of Computing Systems                 Computer Organization and Design              Nand2Tetris Bilibili                 Coursera                  1,                  2"},{"location":"resources/databases/","title":"Databases","text":"Book Course Video Architecture of a Database System Berkeley CS186: Introduction to Database Systems              Bilibili Youtube Database Management Systems Transaction Processing: Concepts and Techniques Database System Concepts CMU 15-445/645: Database Systems (Fall 2023)              Youtube Readings in Database Systems Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World"},{"location":"resources/distributed-systems/","title":"Distributed Systems","text":"Book Course Video Designing Data-Intensive Applications MIT 6.824: Distributed Systems              Bilibili Youtube Official Distributed Systems, 4th                  Paper List: here; Paper We Loved: here"},{"location":"resources/languages/","title":"Languages and Compilers","text":"Book Course Video Crafting Interpreters Compilers: Principles, Techniques &amp; Tools Stanford CS143: Compilers              Bilibili Youtube edX"},{"location":"resources/math/","title":"Math for CS","text":"Subject Book Course Video Discrete Mathematics lecture notes by L\u00e1szl\u00f3 Lov\u00e1sz MIT 6.042J: Mathematics for Computer Science              Bilibili Youtube Mathematics for Computer Science UCB CS70: Discrete Mathematics and Probability Theory              Bilibili Youtube Linear Algebra Introduction to Linear Algebra Essence of linear algebra Bilibili Youtube MIT 18.06SC: Linear Algebra              Bilibili Youtube"},{"location":"resources/networking/","title":"Computer Networking","text":"Book Course Video Computer Networking: A Top-Down Approach Stanford CS144: Introduction to Computer Networking              Bilibili Youtube Jim Kurose's lecture Bilibili Official"},{"location":"resources/operating-systems/","title":"Operating Systems","text":"Step Book Course Video Step 1: Learning the basic Operating Systems: Three Easy Pieces MIT 6.S081: Operating System Engineering              Bilibili Official Operating Systems: Principles and Practice UCB CS162: Operating Systems and System Programming              Bilibili Youtube Operating System Concepts Modern Operating Systems Step 2: explore the design decisions of specific operating systems Lion's commentary on Unix The Design and Implementation of the FreeBSD Operating System Mac OS X Internals Linux Kernel Development <p>A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features. One choice is xv6,     a port of Unix V6 to ANSI C and x86, maintained for a course at MIT. OSTEP has an appendix of potential xv6 labs full of great ideas for potential projects.</p>"},{"location":"resources/others/","title":"Other","text":"Book Course Video MIT 6.031 notes MIT 6.031: Software Construction              Engineering Software as a Service UCB CS169: Software Engineering              Bilibili Book video MIT Web Development Crash Course MIT Web Development Crash Course Youtube"},{"location":"resources/programming/","title":"Programming","text":"<p>This part is an introduction to computer programming, and here are books and courses I recommend to you:</p> Book Course Video Structure and Interpretation of Computer Programs Brian Harvey's UCB CS61A: Structure and Interpretation of Computer Programs (Spring 2010)              Bilibili Youtube MIT 6.001: Structure and Interpretation of Computer Programs                               Harold Abelson's in 1986: Bilibili Youtube                  Eric Grimson's in 2004: Bilibili Youtube How to design programs / / Composing Programs John DeNero's UCB CS61A: Structure and Interpretation of Computer Programs (Fall 2020)              Bilibili Official <p>These are open classes for other specific programming languages:</p> <ul> <li>General         <ol> <li>MIT's The Missing Semester of Your CS Education:                  Bilibili;                  Youtube </li> <li>Harvard's CS50x:                  Bilibili;                  Youtube </li> </ol> </li> <li>Python         <ol> <li> Harvard's CS50 Python:                  Bilibili;                  Youtube </li> <li> Python for Everybody by Dr. Chuck                 Bilibili,                  Youtube </li> </ol> </li> <li>C         <ol> <li>C Programming for Everybody by Dr. Chuck:                 Youtube </li> </ol> </li> </ul>"}]}